syntax = "proto3";
package pb;

service Host {
  rpc Stream(stream ClientMessage) returns (stream HostMessage);
}

message ClientMessage {
  oneof message {
    // Sent if this client wants to join the next game. Host response is PlayersUpdate or error.
    Player join_request = 1;
    // Sent only by players after host sends GameStart.
    bytes game_start_sig = 2;
    // Sent only by players after host sends HandStart.
    bytes hand_start_sig = 3;
    // Sent after shuffle_stage_1 and shuffle_stage_2.
    DeckShuffle shuffle_response = 4;
    // Sent after card_decryption from host.
    bytes card_decryption_key = 5;
    // Sent when it is this player's turn and they choose to play a card.
    PlayCard play_card = 6;
    // Sent when it is this player's turn and they choose to draw a card.
    bool draw_card = 7;
    // Sent when host sends hand_finish_stage_1.
    HandInfo reveal_hand = 8;
    // Sent when host sends hand_finish_stage_2.
    bytes hand_finished_sig = 9;
    // Sent to host on any error. May or may not terminate afterwards.
    string error = 10;
  }

  message DeckShuffle {
    // The set of cards that are affected depending on which stage
    repeated bytes working_card_set = 1;
  }

  message PlayCard {
    // The encrypted card to play.
    bytes encrypted_card = 1;
    // The unencrypted card to play.
    int32 unencrypted_card = 2;
    // Everyone's card decryption keys, by player index.
    repeated bytes card_decryption_keys = 3;
    // If the card is a wild card, this is its color.
    int32 wild_color = 4;
  }

  message HandInfo {
    // The set of encrypted cards the player holds.
    repeated bytes encrypted_cards_in_hand = 1;
    // The set of unencrypted cards the player holds.
    repeated int32 unencrypted_cards_in_hand = 2;
    // The map of all the player's decryption keys for all cards.
    map<string, bytes> card_decryption_keys = 3;
  }
}

message HostMessage {
  oneof message {
    // This message is generated on first connect. Clients should not do anything until they receive this message.
    Welcome welcome = 1;
    // This message is sent if the set of players changes. This cannot occur if there is a game going on.
    PlayersUpdate players_update = 2;
    // Any update to the game state.
    GameUpdate game_update = 3;
    // A chat message is added. This message can occur out of band.
    ChatMessageAdded chat_update = 4;
    // Sent when a game is about to start.
    GameStart game_start = 5;
    // Sent when a hand is about to start.
    HandStart hand_start = 6;
    // Sent only to players when it is time to shuffle a deck. This is either a deck on start or when the deck is empty
    // and the discard pile sans top card becomes the next deck. This is stage 1 of a mental poker shuffle.
    DeckShuffle shuffle_stage_1 = 7;
    // Sent only to players when shuffle stage 1 is complete for everyone. This is stage 2 of a mental poker shuffle.
    DeckShuffle shuffle_stage_2 = 8;
    // Sent only to player when shuffle stage 2 is complete for everyone. This is the completion of the mental poker
    // shuffle.
    DeckShuffle shuffle_complete = 9;
    // Sent to all players but the player needing the card.
    GetCardDecryption card_decryption = 10;
    // Sent to the player needing the card.
    GiveCard give_card = 11;
    // Sent to everyone when one-left has been called.
    OneLeftCalled one_left_called = 12;
    // Sent to players when the hand has completed. This asks everyone for their cards and known decryption keys.
    bool hand_finish_stage_1 = 13;
    // Sent to players when the game has completed. This has everyone's cards, decryption keys, and new scores.
    HandFinish hand_finish_stage_2 = 14;
    // Sent to everyone when hand has completed. This has everything hand finish does and some sigs.
    HandComplete hand_complete = 15;
    // Any kind of error. It may terminate connection.
    string error = 16;
  }

  message Welcome {
    // This is the set of players at the table. It does not represent all spectators.
    repeated Player players = 1;
    // The current game state or not present if no current game.
    GameUpdate game_update = 2;
    // Some of the most recent chat messages (older first).
    repeated ChatMessage chat_messages = 3;
  }

  message PlayersUpdate {
    // The current set of players.
    repeated Player players = 1;
  }

  message GameUpdate {
    // The ID of this game. Always non-empty.
    bytes game_id = 1;
    // The ID of the current hand. Always non-empty.
    bytes hand_id = 2;
    // The number of cards in the draw pile.
    int32 deck_remaining = 3;
    // The cards in the discard pile. Always non-empty.
    repeated uint32 discard_stack = 4;
    // The number of cards each player has. Always same length as player count.
    repeated uint32 player_card_counts = 5;
    // The score of each player at the start of the hand. Always same length as player count.
    repeated uint32 player_scores = 6;
    // The stated color of the last seen wild card.
    uint32 last_wild_color = 7;
    // The index in the player array of the dealer for this hand.
    uint32 dealer_index = 8;
    // The index in the player array of the next to go player.
    uint32 current_player_index = 9;
    // Whether the direction is forward.
    bool forward = 10;
    // The shared prime from hand start.
    bytes shared_card_prime = 11;
    // The encrypted version of the last discard card.
    bytes last_discard_encrypted_card = 12;
    // The decryption keys of the last discard card by player index.
    repeated bytes last_discard_decryption_keys = 13;
    // If set, this is the reason the entire game is complete. TODO: fix
    oneof completion_reason {
      // An error occurred ending the game. Empty if no error.
      string error = 14;
      // A person has won the game or caused the error.
      bytes player_id = 15;
    }
  }

  message ChatMessageAdded {
    // The chat message, always present.
    ChatMessage message = 1;
    // The host's UTC, always non-zero.
    uint64 utc_ms = 2;
  }

  message GameStart {
    // The ID of this new game.
    bytes id = 1;
    // The set of players that are participating in this game. Always at least 2.
    repeated Player players = 3;
  }

  message HandStart {
    // The ID of this hand.
    bytes id = 1;
    // The prime that will be used for shuffling during this hand.
    bytes shared_card_prime = 2;
    // The scores of the players at the start of this hand.
    repeated uint32 player_scores = 3;
    // The index of the dealer for this hand.
    uint32 dealer_index = 4;
    // The signatures of the game start binaries for the players.
    repeated bytes game_start_player_sigs = 5;
  }

  message DeckShuffle {
    // The set of cards this shuffle started with. Never changed. In order of a standard deck on hand start or the
    // discard pile sans top card on discard rotation.
    repeated uint32 unencrypted_start_cards = 1;
    // The set of cards to work with. These are encrypted. Stage 1 they are encrypted with one key and shuffled. Stage 2
    // they are unencrypted from the one key and re-encrypted with a per-card key. Completion, they are just stored.
    repeated bytes working_card_set = 2;
    // The set of signatures of the HandStart message for each player.
    repeated bytes hand_start_player_sigs = 3;
  }

  message GetCardDecryption {
    // The fully encrypted card ID as it appeared at last deck shuffle completion.
    bytes encrypted_card = 1;
    // The player this will be given to. Can be empty if it's at the start of the game and this is for for removing the
    // top card on start.
    bytes target_player_id = 2;
  }

  message GiveCard {
    // The fully encrypted card 
    bytes encrypted_card = 1;
    // Decryption keys from all players except myself in order of player (so self is empty).
    repeated bytes decryption_keys = 2;
  }

  message OneLeftCalled {
    // Who called it
    bytes caller_id = 1;
    // Who has only one left
    bytes target_id = 2;
  }

  message HandFinish {
    // The infos for each player.
    repeated PlayerInfo info = 1;
    // The set of encrypted cards in the deck.
    repeated bytes encrypted_cards_in_deck = 2;
    // The set of unencrypted cards in the deck.
    repeated uint32 unencrypted_cards_in_deck = 3;

    message PlayerInfo {
      // The set of encrypted cards the player holds.
      repeated bytes encrypted_cards_in_hand = 1;
      // The set of unencrypted cards the player holds.
      repeated int32 unencrypted_cards_in_hand = 2;
      // The map of all the player's decryption keys for all cards.
      map<string, bytes> card_decryption_keys = 3;
      // The score for this player after the hand.
      int32 score = 4;
    }
  }

  message HandComplete {
    // The entire hand finish that was sent to all players.
    HandFinish hand_finish = 1;
    // The signatures of the hand finish structure by each player.
    repeated bytes hand_finish_player_sigs = 2;
  }
}

message ChatMessage {
  bytes player_id = 1;
  int64 nonce = 2;
  string contents = 3;
  bytes sig = 4;
}

message Player {
  bytes id = 1;
  bytes pub_key = 2;
  string name = 3;
  bytes sig = 4;
}